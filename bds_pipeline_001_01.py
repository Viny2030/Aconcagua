# -*- coding: utf-8 -*-
"""bds-pipeline-001-01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/gist/cristiandarioortegayubro/767501b3a8c383730038fbf658b57486/bds-pipeline-001-01.ipynb

<p align="center">
<img src="https://github.com/cristiandarioortegayubro/BDS/blob/main/images/Logo%20Scikit-learn.png?raw=true">
</p>

# **<font color="DeepPink">Historia de scikit-learn</font>**

<p align="justify">
La historia de scikit-learn es interesante, ya que se ha convertido en una de las bibliotecas de aprendizaje automÃ¡tico mÃ¡s populares y ampliamente utilizadas en el ecosistema de Python.
<br><br>
ğŸ‘€ Resumen de su historia:
<br><br>
<ol align="justify">
<li>
<b>OrÃ­genes y lanzamiento inicial:</b>
   Scikit-learn fue creado por David Cournapeau en 2007 como parte de su tesis doctoral en la Universidad TecnolÃ³gica de Nueva Gales del Sur, en Australia. Originalmente, la biblioteca se llamaba "scikits.learn" y se diseÃ±Ã³ como un proyecto de cÃ³digo abierto para proporcionar herramientas simples y eficientes para el aprendizaje automÃ¡tico en Python. La primera versiÃ³n pÃºblica fue lanzada en el aÃ±o 2010.
</li>
<li>
<b>Crecimiento y adopciÃ³n:</b>
   Desde su lanzamiento inicial, scikit-learn ha experimentado un crecimiento significativo en tÃ©rminos de funcionalidad, rendimiento y popularidad. Se han agregado numerosos algoritmos de aprendizaje automÃ¡tico, herramientas de preprocesamiento de datos, mÃ©tricas de evaluaciÃ³n y utilidades para facilitar el desarrollo de modelos predictivos y anÃ¡lisis de datos.
</li>
<li>
<b>Contribuciones y comunidad:</b>
   Una de las fortalezas de scikit-learn es su activa comunidad de desarrolladores y contribuyentes. A lo largo de los aÃ±os, cientos de desarrolladores han contribuido al proyecto, aÃ±adiendo nuevas caracterÃ­sticas, corrigiendo errores y mejorando la documentaciÃ³n. Esto ha permitido que scikit-learn evolucione rÃ¡pidamente y se mantenga al dÃ­a con los avances en el campo del aprendizaje automÃ¡tico.
</li>
<li>
<b>Reconocimiento y uso generalizado:</b>
   Scikit-learn ha sido ampliamente reconocido en la comunidad de aprendizaje automÃ¡tico por su facilidad de uso, su enfoque en la simplicidad y su amplia gama de algoritmos implementados. Se ha convertido en una herramienta estÃ¡ndar para estudiantes, acadÃ©micos, investigadores y profesionales de la industria que trabajan en aprendizaje automÃ¡tico y anÃ¡lisis de datos.
</li>
<li>
<b>IntegraciÃ³n con ecosistema de Python:</b>
   Scikit-learn se integra bien con otras bibliotecas y herramientas populares en el ecosistema de Python, como NumPy, SciPy, Pandas, Matplotlib, Seaborn y Plotly lo que permite construir y desplegar flujos de trabajo completos para el anÃ¡lisis de datos y el desarrollo de modelos predictivos.
</li>
</ol>
<br>
<p align="justify">
âœ… La historia de scikit-learn es la de un proyecto de cÃ³digo abierto que ha crecido desde sus humildes comienzos hasta convertirse en una de las bibliotecas de aprendizaje automÃ¡tico mÃ¡s utilizadas y respetadas en la comunidad de Python. Su simplicidad, funcionalidad y comunidad activa han contribuido en gran medida a su Ã©xito y adopciÃ³n generalizada.

# **<font color="DeepPink">Primer modelo con scikit-learn</font>**

â¤ https://scikit-learn.org/stable/

<p align="justify">
ğŸ‘€ En este Colab, vamos a construir un modelo predictivo de datos tabulares y solo con las variables numÃ©ricas. <br><br>En particular, se destacan las siguientes funciones y mÃ©todos:
</p>

- <code>.fit(X, y)</code> para entrenar.
- <code>.predict(X)</code> para predecir.
- <code>.score(X, y)</code> para evaluar la predicciÃ³n.
- EvaluaciÃ³n del rendimiento del modelo con:
     - un conjunto de datos de entrenamiento.
     - un conjunto de datos de prueba.

<p align="justify"> ğŸ‘€ Los <mark>datos numÃ©ricos</mark> son el tipo de datos que <mark>se utilizan naturalmente en los modelos de aprendizaje automÃ¡tico</mark> y pueden incorporarse directamente a los modelos predictivos, bueno, casi directamente (conviene normalizarlos).<br><br> Ahora a continuaciÃ³n, vamos a cargar un conjunto de  datos, pero solo vamos a trabajar con las columnas numÃ©ricas. Por eso, habilitamos <code>Pandas</code>, <code>Numpy</code> y leemos los datos de <code>Github</code>.</p>
"""

import numpy as np
import pandas as pd

adult_census = pd.read_csv("https://raw.githubusercontent.com/cristiandarioortegayubro/BDS/main/datasets/adult_census.csv")

adult_census

"""<p align="justify">
ğŸ‘€ Vamos a trabajar con los datos del censo.
</p>

Las columnas son:

- Edad - Age
- Clase de Trabajo - Workclass
- Educacion - Education
- Educacion numerica - Education num
- Estado civil - Marital status
- Ocupacion - Occupation
- Relacion - Relationship
- Raza - Race
- Sexo - Sex
- Ganancia de capital - Capital gain
- Perdida de capital - Capital loss
- Horas por semana - Hours per week
- Pais nativo - Native country
- Clase - Class
"""

adult_census.info()

"""<p align="justify">
ğŸ‘€ Asignamos a un objeto la variable objetivo:
</p>

"""

target_column = "class"

"""<p align="justify">
ğŸ‘€ Generamos la lista de las variables (columnas) numericas.
</p>

"""

numerical_columns = ["age",
                     "education-num",
                     "capital-gain",
                     "capital-loss",
                     "hours-per-week"]

"""<p align="justify">
ğŸ‘€ Las columnas numÃ©ricas y la variable objetivo.
</p>
"""

all_columns = numerical_columns + [target_column]

all_columns

df = adult_census[all_columns]

"""ğŸ‘€ Ahora si, nuestro <code>DataFrame</code> de columnas numÃ©ricas..., excepto la variable objetivo que no es numÃ©rica..."""

df.describe().T.round(2)

df

df.dtypes

"""<p align="justify">
âœ… El objetivo con estos datos es predecir si una persona gana mÃ¡s de 50K al aÃ±o a partir de las variables que se encuentran a disposiciÃ³n.
</p>

# **<font color="DeepPink">Algunos conceptos de Aprendizaje AutomÃ¡tico</font>**

<p align="justify">
âœ… En general, un problema de <b>Aprendizaje AutomÃ¡tico</b> considera un conjunto de $n$ muestras de datos y luego trata de predecir las propiedades de los datos desconocidos. Si cada muestra es mÃ¡s que un solo nÃºmero, por ejemplo los datos multivariados, se dice que la muestra tiene varios atributos o caracterÃ­sticas.
<br><br> Vamos a dividir los problemas de Aprendizaje AutomÃ¡tico en dos categorÃ­as:
<br><br>
</p>
<ul align="justify">
<li>
<b>Aprendizaje Supervisado</b>, en el que los datos vienen con atributos adicionales que queremos predecir. El Aprendizaje Supervisado puede ser de:
<ul><li>
<b>ClasificaciÃ³n</b>: las muestras pertenecen a dos (clasificacion binaria) o mÃ¡s clases (clasificacion multiclase) y queremos aprender de los datos ya etiquetados (variable objetivo) para predecir la clase de aquellos datos que no estan etiquetados (datos nuevos). Un ejemplo de un problema de clasificaciÃ³n binaria serÃ­a la predicciÃ³n de la contrataciÃ³n de un seguro ofrecido por un banco, en virtud de las caracteristicas de los clientes del banco.
</li>
<li>
<b>RegresiÃ³n</b>: si la salida deseada consiste en una o mÃ¡s variables continuas, entonces este modelo se llama regresiÃ³n. Un ejemplo de un problema de regresiÃ³n serÃ­a la predicciÃ³n del precio de una propiedad en virtud de las caracteristicas de la propiedad.
</li></ul><br>
<li>
<b>Aprendizaje no Supervisado</b>, en el que los datos de entrenamiento consisten en un conjunto de vectores de entrada $x$ sin ninguna variable objetivo correspondiente, ya que el objetivo de tales problemas de Aprendizaje no Supervisado puede ser descubrir grupos de ejemplos similares dentro de los datos, lo que se denomina agrupamiento, o determinar la distribuciÃ³n de los datos, conocido como estimaciÃ³n de densidad, o proyectar los datos desde un punto de vista de dimensiÃ³n, como por ejemplo, reducir el espacio a dos o tres dimensiones con el propÃ³sito de visualizaciÃ³n.

<p align="center">
<img src="https://github.com/cristiandarioortegayubro/BDS/blob/main/images/ML-001.png?raw=true" width="500">
</p>

# **<font color="DeepPink">Separar la variable objetivo y las variables explicativas</font>**

ğŸ‘€ Ahora vamos a dividir del conjunto de datos, la variable objetivo y las variables explicativas, es decir, vamos a obtener una <code>Serie</code> para la variable objetivo y un <code>DataFrame</code> con las variables explicativas...

## **<font color="DeepPink">Variable objetivo</font>**
"""

y = df[target_column]
y

"""ğŸ‘€ Verificamos que el objeto es una <code>Serie</code>..."""

y.shape

type(y)

""" ## **<font color="DeepPink">Variables explicativas</font>**"""

X = df.drop(columns=["class"])
X

"""ğŸ‘€ Verificamos que el objeto es un <code>DataFrame</code>..."""

type(X)

"""ğŸ‘€ Todas las columnas del <code>DataFrame</code> son numÃ©ricas..."""

X.dtypes

X.shape

print("")
print(f"El conjunto de datos contiene {X.shape[0]} registros y "
      f"{X.shape[1]} variables explicativas")

"""# **<font color="DeepPink">Ajustar un modelo y hacer predicciones</font>**

â¤ https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html

<p align="justify">
ğŸ‘€ Construiremos un modelo de clasificaciÃ³n binaria usando el algoritmo de <code>regresiÃ³n logÃ­stica</code>.
</p>
"""

from sklearn.linear_model import LogisticRegression

model = LogisticRegression()
_ = model.fit(X, y)

"""<p align="justify">
La lÃ­nea de cÃ³digo se divide en dos partes:
<br><br>

1. `model = LogisticRegression()`

<p align="justify">
ğŸ‘€ Esta primera parte crea una instancia de la clase <code>LogisticRegression</code> de scikit-learn. <mark>Esto significa que se estÃ¡ creando un modelo de regresiÃ³n logÃ­stica</mark> que puede ser utilizado para predecir valores futuros.
</p>

2. `_ = model.fit(X, y)`

<p align="justify">
La segunda parte del cÃ³digo entrena el modelo de regresiÃ³n logÃ­stica utilizando los datos de entrenamiento <code>X</code> y <code>y</code>. La variable <code>_</code> se utiliza para indicar que no se necesita el valor de retorno de la funciÃ³n <code>fit</code>. La funciÃ³n <code>fit</code> actualiza los parÃ¡metros del modelo de regresiÃ³n logÃ­stica para que se ajusten mejor a los datos de entrenamiento.
<br><br>
En resumen, el script crea un modelo de regresiÃ³n logÃ­stica y lo entrena utilizando los datos de entrenamiento <code>X</code> y <code>y</code>. La variable <code>_</code> se utiliza para indicar que no se necesita el valor de retorno de la funciÃ³n <code>fit</code>.
<br><br>
ğŸ’– AquÃ­ hay algunos detalles adicionales sobre el script:
<br><br>

* El modelo de regresiÃ³n logÃ­stica es un modelo de aprendizaje automÃ¡tico que se utiliza para predecir valores binarios (es decir, 0 o 1).
* La funciÃ³n `fit` actualiza los parÃ¡metros del modelo de regresiÃ³n logÃ­stica utilizando el algoritmo de optimizaciÃ³n de mÃ¡xima verosimilitud.

<p align="justify">
ğŸ‘€ El mÃ©todo <code>fit</code> que vamos a utilizar, se compone de dos elementos:
</p>

- Un algoritmo de aprendizaje, y
- Algunos estados de los modelos.

<br>
<p align="justify">
El algoritmo de aprendizaje toma el conjunto de datos de entrenamiento y la variable objetivo de entrenamiento como entrada, es decir como <code>input</code> y establece los estados del modelo. Estos estados de los modelos se usarÃ¡n mÃ¡s tarde para predecir (para clasificadores y regresores)
o para transformar datos (para transformadores). <br><br>Tanto el algoritmo de aprendizaje como el tipo de estado del modelo son especÃ­ficos de cada modelo.
</p>

<p align="justify">
ğŸ‘€ Ahora bien, para predecir un modelo se utiliza una funciÃ³n de predicciÃ³n. El mÃ©todo que se utiliza es <code>predict()</code>.
</p>
"""

target_predicted = model.predict(X)

type(target_predicted)

"""<p align="justify">
ğŸ‘€ Ahora observamos las predicciones generadas. Solo veremos las primeras 10  predicciones...
</p>

"""

target_predicted[:10]

"""ğŸ‘€ Y vemos los datos reales..."""

y[:10]

"""ğŸ‘€ Y comparamos los datos reales, con las predicciones, solo para las primeras 10 muestras..."""

y[:10] == target_predicted[:10]

"""ğŸ‘€ Y podemos ver cuantas predicciones son correctas para estas 10 muestras..."""

print("")
print(f"NÃºmero de predicciones correctas: "
      f"{(y[:10] == target_predicted[:10]).sum()} / 10")

"""ğŸ‘€ Y podemos calcular la media de las predicciones correctas..."""

y.shape

(y == target_predicted).mean().round(4)

model.score(X, y).round(4)

"""<p align="justify">
ğŸ‘€ Este resultado significa que el modelo hace una predicciÃ³n correcta para aproximadamente $81$ muestras de $100$ muestras. Hay que tener en cuenta que usamos los mismos datos para entrenar y para evaluar el modelo. Â¿Se puede confiar en esta evaluaciÃ³n, o esta evaluaciÃ³n es demasiado buena para ser verdad?.
<br><br>Para poder responder esa interrogante, en vez de trabajar con todas las muestras, vamos a dividir nuestros datos en un conjunto de datos de entrenamiento y un conjunto de datos de prueba...
</p>

# **<font color="DeepPink">DivisiÃ³n de datos de entrenamiento y prueba</font>**

<p align="justify">
ğŸ‘€ Al construir un modelo de aprendizaje automÃ¡tico, es importante evaluar el modelo entrenado en datos que no se usaron para ajustarlo <code>fit</code>, ya que la generalizaciÃ³n de un modelo es mÃ¡s que la memorizaciÃ³n.
<br><br>
Esto significa que queremos un modelo de aprendizaje que generalice a nuevos datos, y no un modelo que compara con los datos que memorizamos.
<br><br>
Es mÃ¡s difÃ­cil concluir sobre casos nunca vistos, que concluir sobre los casos que ya hemos vistos. Por este motivo, es que se plantea una divisiÃ³n de los datos disponibles.
<br><br>
Por ese motivo, los datos utilizados para ajustar un modelo se denominan datos de entrenamiento, mientras que los datos utilizados para evaluar un modelo se denominan datos de prueba, es decir, dividimos el conjunto de datos en un conjunto de datos de entrenamiento y un conjunto de datos de prueba.
</p>

ğŸ‘€ Nuestro <code>DataFrame</code> tiene las siguientes dimensiones...
"""

df.shape

int(48842*0.2)

"""ğŸ‘€ Vamos a tomar una muestra de 9768 muestras (indices) y luego vamos a resetear el indice de nuestro <code>DataFrame</code> con el mÃ©todo <code>reset_index()</code>. A destacar, usamos el parÃ¡metro <code>random_state</code> para ajustar la pseudoalietoriedad de la selecciÃ³n de las muestras...
<br><br>
Este valor es aproximadamente el $20$% de las muestras del <code>DataFrame</code>...
"""

df_test = df.sample(9768, random_state=123)

df_test.shape

round((df_test.shape[0]/df.shape[0]),3)

"""ğŸ‘€ Ahora vamos a sacar del <code>DataFrame</code> el conjunto de datos de prueba..."""

df_test.head()

df_train = df.drop(index=df_test.index)

round((df_train.shape[0]/df.shape[0]),3)

"""ğŸ‘€ y reseteamos los indices de los dos conjuntos de datos..."""

df_test.reset_index(drop=True, inplace=True)
df_train.reset_index(drop=True, inplace=True)

"""ğŸ‘€ Ahora tenemos un <code>DataFrame</code> de testeo..."""

df_test

df_test.shape

"""ğŸ‘€ Y tenemos un <code>DataFrame</code> sin los datos de la muestra..."""

df_train

df_train.shape

"""ğŸ‘€ De este <code>DataFrame</code> de testeo, separamos en variable objetivo y vector de caracteristicas, la variable objetivo es nuestra $y$, el vector de caracteristicas es nuestro $X$..."""

y_test = df_test["class"]
X_test = df_test.drop(columns=["class"])

y_test.shape

X_test.shape

print("")
print(f"El conjunto de prueba contiene {X_test.shape[0]} registros y "
      f"{X.shape[1]} variables explicativas.")

"""ğŸ‘€ Hacemos lo mismo con el conjunto de datos..."""

y_train = df_train["class"]
X_train = df_train.drop(columns=["class"])

print("")
print(f"El conjunto de prueba contiene {X_train.shape[0]} registros y "
      f"{X.shape[1]} variables explicativas.")

"""<p align="justify">
ğŸ‘€ En lugar de calcular la predicciÃ³n y calcular manualmente la tasa de Ã©xito promedio de esa predicciÃ³n, podemos usar la puntuaciÃ³n del mÃ©todo. Cuando se trata de clasificadores, este mÃ©todo devuelve su mÃ©trica de rendimiento.
</p>

"""

model = LogisticRegression()
_ = model.fit(X_train, y_train)

model

accuracy = model.score(X_test, y_test).round(4)
accuracy

"""ğŸ‘€ El nombre del modelo es..."""

model_name = model.__class__.__name__
model_name

print("")
print(f"El accuracy del modelo {model_name} es "
      f"{accuracy:.4f}")

"""<p align="justify">
ğŸ‘€ Para calcular la puntuaciÃ³n de la mÃ©trica, el predictor primero calcula las predicciones (usando el mÃ©todo de predicciÃ³n) y luego usa una funciÃ³n de puntuaciÃ³n para comparar la variable objetivo real y las predicciones realizadas. Finalmente, se devuelve la puntuaciÃ³n obtenida en virtud de los aciertos en las predicciones.<br><br>Por lo tanto, es importante probar siempre el rendimiento de generalizaciÃ³n de los modelos predictivos en un conjunto diferente al utilizado para entrenar los modelos, en este caso en el conjunto de prueba.
</p>

"""

model.score(X, y).round(4)

model.score(X_test, y_test).round(4)

"""# **<font color="DeepPink">Conclusiones</font>**

<p align="justify">
ğŸ‘€ En este colab nosotros:
<br><br>
âœ… Cargamos los datos de un archivo <code>CSV</code> usando <code>Pandas</code>.<br>
âœ… Examinamos las variables numÃ©ricas.
<br>  
âœ… Hicimos un modelo con todo el conjunto de datos.
<br>
âœ… Tambien generamos un conjunto de datos de prueba para evaluar.</p>

<br>
<br>
<p align="center"><b>
ğŸ’—
<font color="DeepPink">
Hemos llegado al final de nuestro colab, a seguir codeando...
</font>
</p>
"""